using System.Text;
using ggLang.Compiler.Analysis;
using ggLang.Compiler.Parser.Ast;

namespace ggLang.Compiler.CodeGen;

/// <summary>
/// Generates C code from a ggLang AST.
/// Handles OOP via vtables, struct-based objects,
/// inheritance chains, and virtual dispatch.
/// </summary>
public sealed class CCodeGenerator
{
    private readonly StringBuilder _header = new();
    private readonly StringBuilder _structs = new();
    private readonly StringBuilder _prototypes = new();
    private readonly StringBuilder _implementations = new();
    private readonly SemanticAnalyzer _analyzer;
    private readonly Dictionary<string, ClassDeclaration> _classDeclarations = [];
    private string? _currentClassName;
    private int _indentLevel;
    private HashSet<string> _currentParameters = [];
    private readonly Dictionary<string, string> _localVarTypes = [];  // varName → typeName
    private readonly HashSet<string> _forwardDeclaredVtables = [];
    private readonly HashSet<string> _emittedVtableMembers = [];
    private readonly long _memoryLimit; // Memory limit in bytes (0 = unlimited)
    private readonly bool _noGc;        // Whether GC is disabled (manual memory mode)

    public CCodeGenerator(SemanticAnalyzer analyzer, long memoryLimit = 0, bool noGc = false)
    {
        _analyzer = analyzer;
        _memoryLimit = memoryLimit;
        _noGc = noGc;
    }

    // ====================
    // PUBLIC API
    // ====================

    public string Generate(CompilationUnit unit)
    {
        // Collect all class declarations
        foreach (var typeDecl in unit.TypeDeclarations)
        {
            if (typeDecl is ClassDeclaration classDecl)
                _classDeclarations[classDecl.Name] = classDecl;
        }

        // Generate header
        _header.AppendLine("/* Generated by ggLang compiler */");

        // Emit runtime configuration defines
        if (_noGc)
        {
            _header.AppendLine("#define GG_NO_GC 1");
        }
        if (_memoryLimit > 0)
        {
            _header.AppendLine($"#define GG_MEMORY_LIMIT {_memoryLimit}L");
        }
        _header.AppendLine();

        _header.AppendLine("#include <stdio.h>");
        _header.AppendLine("#include <stdlib.h>");
        _header.AppendLine("#include <string.h>");
        _header.AppendLine("#include <stdbool.h>");
        _header.AppendLine("#include \"gg_runtime.h\"");
        _header.AppendLine();

        // Forward declare all structs and vtables
        foreach (var classDecl in _classDeclarations.Values)
        {
            _structs.AppendLine($"typedef struct {classDecl.Name} {classDecl.Name};");
            _structs.AppendLine($"typedef struct {classDecl.Name}_VTable {classDecl.Name}_VTable;");
            _forwardDeclaredVtables.Add(classDecl.Name);
        }
        _structs.AppendLine();

        // Generate vtable structs, class structs, and implementations
        foreach (var typeDecl in unit.TypeDeclarations)
        {
            if (typeDecl is ClassDeclaration classDecl)
            {
                GenerateVTableStruct(classDecl);
                GenerateClassStruct(classDecl);
            }
        }

        // Forward declare vtable instances (needed before constructors reference them)
        foreach (var typeDecl in unit.TypeDeclarations)
        {
            if (typeDecl is ClassDeclaration classDecl)
            {
                _structs.AppendLine($"extern {classDecl.Name}_VTable {classDecl.Name}_vtable_instance;");
            }
        }
        _structs.AppendLine();

        foreach (var typeDecl in unit.TypeDeclarations)
        {
            if (typeDecl is ClassDeclaration classDecl)
            {
                GenerateClassImplementation(classDecl);
            }
        }

        // Assemble output
        var sb = new StringBuilder();
        sb.Append(_header);
        sb.Append(_structs);
        sb.Append(_prototypes);
        sb.AppendLine();
        sb.Append(_implementations);
        return sb.ToString();
    }

    // ====================
    // VTABLE GENERATION
    // ====================

    /// <summary>
    /// Generates the vtable struct for a class.
    /// Collects all virtual/override methods from the entire inheritance chain,
    /// deduplicating members.
    /// </summary>
    private void GenerateVTableStruct(ClassDeclaration classDecl)
    {
        _emittedVtableMembers.Clear();
        _structs.AppendLine($"struct {classDecl.Name}_VTable {{");

        // Collect all virtual methods from inheritance chain
        var vtableMethods = CollectVTableMethods(classDecl);

        foreach (var (methodName, method) in vtableMethods)
        {
            if (_emittedVtableMembers.Add(methodName))
            {
                var returnType = MapType(method.ReturnType);
                var paramList = $"{classDecl.Name}* self";
                foreach (var param in method.Parameters)
                {
                    paramList += $", {MapType(param.Type)} {param.Name}";
                }
                _structs.AppendLine($"    {returnType} (*{methodName})({paramList});");
            }
        }

        _structs.AppendLine("};");
        _structs.AppendLine();
    }

    /// <summary>
    /// Collects all virtual methods from the entire inheritance chain,
    /// with derived class methods overriding base class ones.
    /// </summary>
    private List<(string Name, MethodDeclaration Method)> CollectVTableMethods(ClassDeclaration classDecl)
    {
        var methods = new Dictionary<string, MethodDeclaration>();

        // Walk up to the root of the hierarchy and collect methods top-down
        var chain = GetInheritanceChain(classDecl);
        chain.Reverse(); // base → derived

        foreach (var cls in chain)
        {
            foreach (var member in cls.Members)
            {
                if (member is MethodDeclaration method && (method.IsVirtual || method.IsOverride || method.IsAbstract))
                {
                    methods[method.Name] = method; // override replaces base
                }
            }
        }

        return methods.Select(kvp => (kvp.Key, kvp.Value)).ToList();
    }

    /// <summary>
    /// Gets the inheritance chain from current class back to root.
    /// Returns [current, parent, grandparent, ...].
    /// </summary>
    private List<ClassDeclaration> GetInheritanceChain(ClassDeclaration classDecl)
    {
        var chain = new List<ClassDeclaration> { classDecl };
        var current = classDecl;
        while (current.BaseClass != null && _classDeclarations.TryGetValue(current.BaseClass, out var parent))
        {
            chain.Add(parent);
            current = parent;
        }
        return chain;
    }

    // ====================
    // CLASS STRUCT GENERATION
    // ====================

    private void GenerateClassStruct(ClassDeclaration classDecl)
    {
        _structs.AppendLine($"struct {classDecl.Name} {{");
        _structs.AppendLine($"    {classDecl.Name}_VTable* _vtable;");

        // Collect all fields from inheritance chain (base first)
        var chain = GetInheritanceChain(classDecl);
        chain.Reverse();
        var emittedFields = new HashSet<string>();

        foreach (var cls in chain)
        {
            foreach (var member in cls.Members)
            {
                if (member is FieldDeclaration field && !field.IsStatic && emittedFields.Add(field.Name))
                {
                    _structs.AppendLine($"    {MapType(field.Type)} {field.Name};");
                }
            }
        }

        _structs.AppendLine("};");
        _structs.AppendLine();
    }

    // ====================
    // CLASS IMPLEMENTATION
    // ====================

    private void GenerateClassImplementation(ClassDeclaration classDecl)
    {
        _currentClassName = classDecl.Name;

        // Static fields
        foreach (var member in classDecl.Members)
        {
            if (member is FieldDeclaration field && field.IsStatic)
            {
                _implementations.AppendLine(
                    $"{MapType(field.Type)} {classDecl.Name}_{field.Name};");
            }
        }

        // Methods (both regular and virtual/override)
        foreach (var member in classDecl.Members)
        {
            if (member is MethodDeclaration method)
            {
                GenerateMethod(classDecl, method);
            }
        }

        // Constructor
        foreach (var member in classDecl.Members)
        {
            if (member is ConstructorDeclaration ctor)
            {
                GenerateConstructor(classDecl, ctor);
            }
        }

        // VTable instance
        GenerateVTableInstance(classDecl);

        // Create function (factory)
        GenerateCreateFunction(classDecl);

        _currentClassName = null;
    }

    private void GenerateMethod(ClassDeclaration classDecl, MethodDeclaration method)
    {
        var returnType = MapType(method.ReturnType);
        var paramList = method.IsStatic ? "" : $"{classDecl.Name}* self";

        _localVarTypes.Clear();
        foreach (var param in method.Parameters)
        {
            if (paramList.Length > 0) paramList += ", ";
            paramList += $"{MapType(param.Type)} {param.Name}";
            _currentParameters.Add(param.Name);
            _localVarTypes[param.Name] = param.Type.Name;
        }

        var funcName = method.IsStatic
            ? $"{classDecl.Name}_{method.Name}"
            : $"{classDecl.Name}_{method.Name}";

        // Prototype
        _prototypes.AppendLine($"{returnType} {funcName}({paramList});");

        // Implementation
        if (method.Body != null)
        {
            _implementations.AppendLine($"{returnType} {funcName}({paramList}) {{");
            _indentLevel = 1;
            GenerateBlock(method.Body);
            _implementations.AppendLine("}");
            _implementations.AppendLine();
        }

        _currentParameters = [];
    }

    private void GenerateConstructor(ClassDeclaration classDecl, ConstructorDeclaration ctor)
    {
        var paramList = $"{classDecl.Name}* self";

        _localVarTypes.Clear();
        foreach (var param in ctor.Parameters)
        {
            paramList += $", {MapType(param.Type)} {param.Name}";
            _currentParameters.Add(param.Name);
            _localVarTypes[param.Name] = param.Type.Name;
        }

        var funcName = $"{classDecl.Name}_construct";

        // Prototype
        _prototypes.AppendLine($"void {funcName}({paramList});");

        // Implementation
        _implementations.AppendLine($"void {funcName}({paramList}) {{");
        _indentLevel = 1;

        // Base constructor call first
        if (ctor.BaseArguments != null && classDecl.BaseClass != null)
        {
            var baseArgs = $"({classDecl.BaseClass}*)self";
            foreach (var arg in ctor.BaseArguments)
            {
                baseArgs += ", " + GenerateExpression(arg);
            }
            Emit($"{classDecl.BaseClass}_construct({baseArgs});");
        }
        else if (classDecl.BaseClass != null)
        {
            // Implicit base call with no args
            Emit($"{classDecl.BaseClass}_construct(({classDecl.BaseClass}*)self);");
        }

        // Set vtable AFTER base constructor so derived vtable isn't overwritten
        Emit($"self->_vtable = &{classDecl.Name}_vtable_instance;");

        // Body
        if (ctor.Body != null)
        {
            GenerateBlock(ctor.Body);
        }

        _implementations.AppendLine("}");
        _implementations.AppendLine();
        _currentParameters = [];
    }

    /// <summary>
    /// Generates the static vtable instance for a class, including
    /// inherited method wrappers for virtual dispatch.
    /// </summary>
    private void GenerateVTableInstance(ClassDeclaration classDecl)
    {
        var vtableMethods = CollectVTableMethods(classDecl);
        if (vtableMethods.Count == 0)
        {
            // Still need to declare the vtable instance even if empty
            _implementations.AppendLine(
                $"{classDecl.Name}_VTable {classDecl.Name}_vtable_instance = {{}};");
            _implementations.AppendLine();
            return;
        }

        // Generate wrapper functions for inherited methods that need type casting
        var chain = GetInheritanceChain(classDecl);
        foreach (var (methodName, _) in vtableMethods)
        {
            // Find which class actually implements this method
            string? implementingClass = null;
            foreach (var cls in chain) // current → parent → ...
            {
                foreach (var member in cls.Members)
                {
                    if (member is MethodDeclaration m &&
                        m.Name == methodName &&
                        (m.IsVirtual || m.IsOverride))
                    {
                        implementingClass = cls.Name;
                        break;
                    }
                }
                if (implementingClass != null) break;
            }

            // Generate wrapper if method is inherited (implemented in parent)
            if (implementingClass != null && implementingClass != classDecl.Name)
            {
                var method = FindMethod(implementingClass, methodName);
                if (method != null)
                {
                    var wrapperName = $"{classDecl.Name}_wrap_{methodName}";
                    var returnType = MapType(method.ReturnType);
                    var wrapperParams = $"{classDecl.Name}* self";
                    var callArgs = $"({implementingClass}*)self";

                    foreach (var p in method.Parameters)
                    {
                        wrapperParams += $", {MapType(p.Type)} {p.Name}";
                        callArgs += $", {p.Name}";
                    }

                    _implementations.AppendLine(
                        $"{returnType} {wrapperName}({wrapperParams}) {{");
                    var call = $"{implementingClass}_{methodName}({callArgs})";
                    if (returnType != "void")
                        _implementations.AppendLine($"    return {call};");
                    else
                        _implementations.AppendLine($"    {call};");
                    _implementations.AppendLine("}");
                    _implementations.AppendLine();
                }
            }
        }

        // VTable instance
        _implementations.AppendLine(
            $"{classDecl.Name}_VTable {classDecl.Name}_vtable_instance = {{");

        for (int i = 0; i < vtableMethods.Count; i++)
        {
            var (methodName, _) = vtableMethods[i];
            var comma = i < vtableMethods.Count - 1 ? "," : "";

            // Find implementing class
            string funcRef;
            string? implementingClass = null;
            foreach (var cls in chain)
            {
                foreach (var member in cls.Members)
                {
                    if (member is MethodDeclaration m &&
                        m.Name == methodName &&
                        (m.IsVirtual || m.IsOverride))
                    {
                        implementingClass = cls.Name;
                        break;
                    }
                }
                if (implementingClass != null) break;
            }

            if (implementingClass == classDecl.Name)
            {
                funcRef = $"{classDecl.Name}_{methodName}";
            }
            else
            {
                funcRef = $"{classDecl.Name}_wrap_{methodName}";
            }

            _implementations.AppendLine($"    .{methodName} = {funcRef}{comma}");
        }

        _implementations.AppendLine("};");
        _implementations.AppendLine();
    }

    private MethodDeclaration? FindMethod(string className, string methodName)
    {
        if (!_classDeclarations.TryGetValue(className, out var classDecl))
            return null;

        foreach (var member in classDecl.Members)
        {
            if (member is MethodDeclaration m && m.Name == methodName)
                return m;
        }
        return null;
    }

    private void GenerateCreateFunction(ClassDeclaration classDecl)
    {
        // Find constructor
        ConstructorDeclaration? ctor = null;
        foreach (var member in classDecl.Members)
        {
            if (member is ConstructorDeclaration c)
            {
                ctor = c;
                break;
            }
        }

        var paramList = "";
        var ctorArgs = "";

        if (ctor != null)
        {
            foreach (var param in ctor.Parameters)
            {
                if (paramList.Length > 0) paramList += ", ";
                paramList += $"{MapType(param.Type)} {param.Name}";
                ctorArgs += $", {param.Name}";
            }
        }

        // Prototype
        _prototypes.AppendLine($"{classDecl.Name}* {classDecl.Name}_create({paramList});");

        // Implementation
        _implementations.AppendLine(
            $"{classDecl.Name}* {classDecl.Name}_create({paramList}) {{");
        _implementations.AppendLine(
            $"    {classDecl.Name}* obj = ({classDecl.Name}*)gg_alloc(sizeof({classDecl.Name}));");

        if (ctor != null)
        {
            _implementations.AppendLine($"    {classDecl.Name}_construct(obj{ctorArgs});");
        }
        else
        {
            _implementations.AppendLine($"    obj->_vtable = &{classDecl.Name}_vtable_instance;");
        }

        _implementations.AppendLine("    return obj;");
        _implementations.AppendLine("}");
        _implementations.AppendLine();
    }

    // ====================
    // STATEMENT CODE GEN
    // ====================

    private void GenerateBlock(BlockStatement block)
    {
        foreach (var stmt in block.Statements)
        {
            GenerateStatement(stmt);
        }
    }

    private void GenerateStatement(Statement stmt)
    {
        switch (stmt)
        {
            case VariableDeclarationStatement varDecl:
                GenerateVarDecl(varDecl);
                break;

            case IfStatement ifStmt:
                Emit($"if ({GenerateExpression(ifStmt.Condition)}) {{");
                _indentLevel++;
                GenerateStatementBody(ifStmt.ThenBranch);
                _indentLevel--;
                if (ifStmt.ElseBranch != null)
                {
                    Emit("} else {");
                    _indentLevel++;
                    GenerateStatementBody(ifStmt.ElseBranch);
                    _indentLevel--;
                }
                Emit("}");
                break;

            case WhileStatement whileStmt:
                Emit($"while ({GenerateExpression(whileStmt.Condition)}) {{");
                _indentLevel++;
                GenerateStatementBody(whileStmt.Body);
                _indentLevel--;
                Emit("}");
                break;

            case ForStatement forStmt:
                GenerateForStatement(forStmt);
                break;

            case ForEachStatement foreachStmt:
                GenerateForEachStatement(foreachStmt);
                break;

            case ReturnStatement retStmt:
                if (retStmt.Value != null)
                    Emit($"return {GenerateExpression(retStmt.Value)};");
                else
                    Emit("return;");
                break;

            case BreakStatement:
                Emit("break;");
                break;

            case ContinueStatement:
                Emit("continue;");
                break;

            case ExpressionStatement exprStmt:
                Emit($"{GenerateExpression(exprStmt.Expression)};");
                break;

            case BlockStatement block:
                Emit("{");
                _indentLevel++;
                GenerateBlock(block);
                _indentLevel--;
                Emit("}");
                break;
        }
    }

    private void GenerateStatementBody(Statement stmt)
    {
        if (stmt is BlockStatement block)
            GenerateBlock(block);
        else
            GenerateStatement(stmt);
    }

    private void GenerateVarDecl(VariableDeclarationStatement varDecl)
    {
        string cType;
        string typeName;
        if (varDecl.Type != null)
        {
            cType = MapType(varDecl.Type);
            typeName = varDecl.Type.Name;
        }
        else
        {
            typeName = InferCType(varDecl.Initializer);
            cType = MapTypeNameWithPointer(typeName);
        }

        // Track local variable type for method dispatch
        _localVarTypes[varDecl.Name] = typeName;

        if (varDecl.Initializer != null)
        {
            var initExpr = GenerateExpression(varDecl.Initializer);
            Emit($"{cType} {varDecl.Name} = {initExpr};");
        }
        else
        {
            Emit($"{cType} {varDecl.Name};");
        }
    }

    private string InferCType(Expression? expr)
    {
        if (expr == null) return "int";

        return expr switch
        {
            LiteralExpression lit => lit.LiteralType switch
            {
                LiteralType.Integer => "int",
                LiteralType.Float => "double",
                LiteralType.String => "string",
                LiteralType.Char => "char",
                LiteralType.Boolean => "bool",
                _ => "int"
            },
            ObjectCreationExpression obj => obj.TypeName,
            MethodCallExpression call => InferMethodCallReturnType(call) ?? "int",
            _ => "int"
        };
    }

    private void GenerateForStatement(ForStatement forStmt)
    {
        // Convert to C-style for loop
        var init = "";
        if (forStmt.Initializer is VariableDeclarationStatement varDecl)
        {
            var cType = MapTypeName(varDecl.Type?.Name ?? InferCType(varDecl.Initializer));
            init = varDecl.Initializer != null
                ? $"{cType} {varDecl.Name} = {GenerateExpression(varDecl.Initializer)}"
                : $"{cType} {varDecl.Name}";
        }
        else if (forStmt.Initializer is ExpressionStatement initExpr)
        {
            init = GenerateExpression(initExpr.Expression);
        }

        var cond = forStmt.Condition != null ? GenerateExpression(forStmt.Condition) : "";
        var inc = forStmt.Increment != null ? GenerateExpression(forStmt.Increment) : "";

        Emit($"for ({init}; {cond}; {inc}) {{");
        _indentLevel++;
        GenerateStatementBody(forStmt.Body);
        _indentLevel--;
        Emit("}");
    }

    private void GenerateForEachStatement(ForEachStatement foreachStmt)
    {
        // Simplified: generate as indexed loop over array
        var collection = GenerateExpression(foreachStmt.Collection);
        var varType = foreachStmt.VariableType != null
            ? MapType(foreachStmt.VariableType)
            : "int";

        Emit($"// foreach ({foreachStmt.VariableName} in {collection})");
        Emit($"for (int _i = 0; _i < {collection}_length; _i++) {{");
        _indentLevel++;
        Emit($"{varType} {foreachStmt.VariableName} = {collection}[_i];");
        GenerateStatementBody(foreachStmt.Body);
        _indentLevel--;
        Emit("}");
    }

    // ====================
    // EXPRESSION CODE GEN
    // ====================

    private string GenerateExpression(Expression expr)
    {
        return expr switch
        {
            LiteralExpression lit => GenerateLiteral(lit),
            NullLiteralExpression => "NULL",
            ThisExpression => "self",
            BaseExpression => "(self)",
            IdentifierExpression id => GenerateIdentifier(id),
            BinaryExpression bin =>
                $"({GenerateExpression(bin.Left)} {bin.Operator} {GenerateExpression(bin.Right)})",
            UnaryExpression unary =>
                $"({unary.Operator}{GenerateExpression(unary.Operand)})",
            PostfixExpression postfix =>
                $"({GenerateExpression(postfix.Operand)}{postfix.Operator})",
            AssignmentExpression assign => GenerateAssignment(assign),
            MemberAccessExpression member => GenerateMemberAccess(member),
            MethodCallExpression call => GenerateMethodCall(call),
            ObjectCreationExpression obj => GenerateObjectCreation(obj),
            ArrayCreationExpression arr =>
                $"({MapType(arr.ElementType)}*)calloc({GenerateExpression(arr.Size)}, sizeof({MapType(arr.ElementType)}))",
            ArrayAccessExpression arrAcc =>
                $"{GenerateExpression(arrAcc.Target)}[{GenerateExpression(arrAcc.Index)}]",
            CastExpression cast =>
                $"(({MapType(cast.TargetType)}){GenerateExpression(cast.Expression)})",
            _ => "/* unknown expr */"
        };
    }

    private string GenerateLiteral(LiteralExpression lit)
    {
        return lit.LiteralType switch
        {
            LiteralType.Integer => lit.Value?.ToString() ?? "0",
            LiteralType.Float => ((double)(lit.Value ?? 0.0)).ToString(
                System.Globalization.CultureInfo.InvariantCulture),
            LiteralType.String => $"\"{EscapeString(lit.Value?.ToString() ?? "")}\"",
            LiteralType.Char => $"'{lit.Value}'",
            LiteralType.Boolean => (bool)(lit.Value ?? false) ? "true" : "false",
            _ => "0"
        };
    }

    private string GenerateIdentifier(IdentifierExpression id)
    {
        // Check if it's a parameter
        if (_currentParameters.Contains(id.Name))
            return id.Name;

        // Check if it's a field access (self->field)
        if (_currentClassName != null && _analyzer.ClassTable.TryGetValue(_currentClassName, out var classInfo))
        {
            // Walk the inheritance chain to find the field
            var current = classInfo;
            while (current != null)
            {
                if (current.Fields.ContainsKey(id.Name))
                    return $"self->{id.Name}";
                if (current.BaseClassName != null)
                    _analyzer.ClassTable.TryGetValue(current.BaseClassName, out current);
                else
                    current = null;
            }
        }

        return id.Name;
    }

    private string GenerateAssignment(AssignmentExpression assign)
    {
        var target = GenerateExpression(assign.Target);
        var value = GenerateExpression(assign.Value);

        return assign.Operator switch
        {
            "=" => $"{target} = {value}",
            "+=" => $"{target} += {value}",
            "-=" => $"{target} -= {value}",
            "*=" => $"{target} *= {value}",
            "/=" => $"{target} /= {value}",
            _ => $"{target} = {value}"
        };
    }

    private string GenerateMemberAccess(MemberAccessExpression member)
    {
        var target = GenerateExpression(member.Target);

        // Class static field: ClassName.field → ClassName_field
        if (member.Target is IdentifierExpression id &&
            _classDeclarations.ContainsKey(id.Name))
        {
            return $"{id.Name}_{member.MemberName}";
        }

        return $"{target}->{member.MemberName}";
    }

    private string GenerateMethodCall(MethodCallExpression call)
    {
        // Console methods
        if (call.Target is MemberAccessExpression memberAccess)
        {
            if (memberAccess.Target is IdentifierExpression targetId)
            {
                // Console.writeLine(...)
                if (targetId.Name == "Console")
                {
                    return GenerateConsoleCall(memberAccess.MemberName, call.Arguments);
                }

                // Math.abs(...) etc
                if (targetId.Name == "Math")
                {
                    return GenerateMathCall(memberAccess.MemberName, call.Arguments);
                }

                // Memory.free(obj) / Memory.alloc(size) — manual memory management
                if (targetId.Name == "Memory")
                {
                    return GenerateMemoryCall(memberAccess.MemberName, call.Arguments);
                }

                // Static method call: ClassName.method(args)
                if (_classDeclarations.ContainsKey(targetId.Name))
                {
                    var args = string.Join(", ", call.Arguments.Select(GenerateExpression));
                    return $"{targetId.Name}_{memberAccess.MemberName}({args})";
                }

                // Try extension method on identifier (e.g., x.toString(), x.round(2))
                var extResult = TryGenerateExtensionCall(memberAccess.Target, memberAccess.MemberName, call.Arguments);
                if (extResult != null) return extResult;

                // Instance method call: check for virtual dispatch
                var objExpr = GenerateExpression(memberAccess.Target);
                var methodName = memberAccess.MemberName;

                // Determine if virtual dispatch is needed
                if (IsVirtualMethod(targetId.Name, methodName))
                {
                    var argParts = call.Arguments.Select(GenerateExpression).ToList();
                    var allArgs = objExpr;
                    if (argParts.Count > 0)
                        allArgs += ", " + string.Join(", ", argParts);
                    return $"{objExpr}->_vtable->{methodName}({allArgs})";
                }
                else
                {
                    // Direct call
                    var resolvedClass = ResolveMethodClass(targetId.Name, methodName);
                    var argParts = call.Arguments.Select(GenerateExpression).ToList();
                    var allArgs = objExpr;
                    if (argParts.Count > 0)
                        allArgs += ", " + string.Join(", ", argParts);
                    return $"{resolvedClass}_{methodName}({allArgs})";
                }
            }

            // Method call on this: this.method(args) → use current class
            if (memberAccess.Target is ThisExpression && _currentClassName != null)
            {
                var methodName2 = memberAccess.MemberName;
                var argParts2 = call.Arguments.Select(GenerateExpression).ToList();
                var allArgs2 = "self";
                if (argParts2.Count > 0)
                    allArgs2 += ", " + string.Join(", ", argParts2);

                // Check if method is virtual
                if (_classDeclarations.TryGetValue(_currentClassName, out var thisClassDecl))
                {
                    var chain = GetInheritanceChain(thisClassDecl);
                    foreach (var cls in chain)
                    {
                        foreach (var member in cls.Members)
                        {
                            if (member is MethodDeclaration m && m.Name == methodName2)
                            {
                                if (m.IsVirtual || m.IsOverride || m.IsAbstract)
                                    return $"self->_vtable->{methodName2}({allArgs2})";
                                else
                                    return $"{cls.Name}_{methodName2}({allArgs2})";
                            }
                        }
                    }
                }
                return $"{_currentClassName}_{methodName2}({allArgs2})";
            }

            // Try extension method on any expression (e.g., (10).toString(), someExpr.round(2))
            var extResult2 = TryGenerateExtensionCall(memberAccess.Target, memberAccess.MemberName, call.Arguments);
            if (extResult2 != null) return extResult2;

            // Method call on expression: expr.method(args)
            var exprTarget = GenerateExpression(memberAccess.Target);
            var exprArgs = call.Arguments.Select(GenerateExpression).ToList();
            var callArgs = exprTarget;
            if (exprArgs.Count > 0)
                callArgs += ", " + string.Join(", ", exprArgs);

            // Try virtual dispatch first
            return $"{exprTarget}->_vtable->{memberAccess.MemberName}({callArgs})";
        }

        // base.method(args) → BaseClass_method(self, args)
        if (call.Target is IdentifierExpression baseId && baseId.Name == "base" && _currentClassName != null)
        {
            // Shouldn't normally get here, handled by member access
        }

        // Simple function call
        if (call.Target is IdentifierExpression funcId)
        {
            var args = string.Join(", ", call.Arguments.Select(GenerateExpression));
            return $"{funcId.Name}({args})";
        }

        return "/* unknown call */";
    }

    private bool IsVirtualMethod(string varName, string methodName)
    {
        // Look up the variable to find its type
        var typeName = ResolveVariableType(varName);
        if (typeName == null) return false;

        if (!_classDeclarations.TryGetValue(typeName, out var classDecl))
            return false;

        var chain = GetInheritanceChain(classDecl);
        foreach (var cls in chain)
        {
            foreach (var member in cls.Members)
            {
                if (member is MethodDeclaration m && m.Name == methodName)
                    return m.IsVirtual || m.IsOverride || m.IsAbstract;
            }
        }

        return false;
    }

    private string ResolveMethodClass(string varName, string methodName)
    {
        var typeName = ResolveVariableType(varName);
        if (typeName == null) return varName;

        if (!_classDeclarations.TryGetValue(typeName, out var classDecl))
            return typeName;

        var chain = GetInheritanceChain(classDecl);
        foreach (var cls in chain)
        {
            foreach (var member in cls.Members)
            {
                if (member is MethodDeclaration m && m.Name == methodName)
                    return cls.Name;
            }
        }

        return typeName;
    }

    private string? ResolveVariableType(string varName)
    {
        // Check local variables first
        if (_localVarTypes.TryGetValue(varName, out var localType))
            return localType;

        // Check fields
        if (_currentClassName != null && _analyzer.ClassTable.TryGetValue(_currentClassName, out var classInfo))
        {
            if (classInfo.Fields.TryGetValue(varName, out var field))
                return field.Type.Name;
        }
        return null;
    }

    private string GenerateConsoleCall(string method, List<Expression> args)
    {
        if (method == "writeLine" || method == "println")
        {
            if (args.Count == 0) return "printf(\"\\n\")";
            var arg = args[0];
            return GeneratePrintCall(arg, true);
        }
        if (method == "write" || method == "print")
        {
            if (args.Count == 0) return "printf(\"\")";
            return GeneratePrintCall(args[0], false);
        }
        if (method == "readLine")
        {
            return "gg_read_line()";
        }
        return $"/* Console.{method}() */";
    }

    private string GeneratePrintCall(Expression arg, bool newline)
    {
        var nl = newline ? "\\n" : "";

        if (arg is LiteralExpression lit)
        {
            return lit.LiteralType switch
            {
                LiteralType.String =>
                    $"printf(\"%s{nl}\", {GenerateExpression(arg)})",
                LiteralType.Integer =>
                    $"printf(\"%lld{nl}\", (long long){GenerateExpression(arg)})",
                LiteralType.Float =>
                    $"printf(\"%f{nl}\", {GenerateExpression(arg)})",
                LiteralType.Boolean =>
                    $"printf(\"%s{nl}\", {GenerateExpression(arg)} ? \"true\" : \"false\")",
                LiteralType.Char =>
                    $"printf(\"%c{nl}\", {GenerateExpression(arg)})",
                _ => $"printf(\"%s{nl}\", {GenerateExpression(arg)})"
            };
        }

        // For expressions, try to infer type
        var exprStr = GenerateExpression(arg);

        // Identifier: look up type
        if (arg is IdentifierExpression id)
        {
            var type = ResolveExpressionType(id);
            return FormatPrintf(type, exprStr, nl);
        }

        // Method call: try to resolve return type
        if (arg is MethodCallExpression callExpr)
        {
            var retType = InferMethodCallReturnType(callExpr);
            if (retType != null)
                return FormatPrintf(retType, exprStr, nl);
        }

        // Binary expression: infer from operands
        if (arg is BinaryExpression binExpr)
        {
            var inferredType = InferExpressionType(binExpr);
            return FormatPrintf(inferredType, exprStr, nl);
        }

        // Unary expression: infer from operand
        if (arg is UnaryExpression unaryExpr)
        {
            var inferredType = InferExpressionType(unaryExpr);
            return FormatPrintf(inferredType, exprStr, nl);
        }

        // Parenthesized or other: try generic inference
        var generalType = InferExpressionType(arg);
        if (generalType != "string" || arg is CastExpression || arg is ArrayAccessExpression)
            return FormatPrintf(generalType, exprStr, nl);

        // Default: assume string
        return $"printf(\"%s{nl}\", {exprStr})";
    }

    private string ResolveExpressionType(IdentifierExpression id)
    {
        // Check local variables first
        if (_localVarTypes.TryGetValue(id.Name, out var localType))
            return localType;

        if (_currentParameters.Contains(id.Name))
        {
            return "string";
        }

        if (_currentClassName != null && _analyzer.ClassTable.TryGetValue(_currentClassName, out var classInfo))
        {
            var current = classInfo;
            while (current != null)
            {
                if (current.Fields.TryGetValue(id.Name, out var field))
                    return field.Type.Name;
                if (current.BaseClassName != null)
                    _analyzer.ClassTable.TryGetValue(current.BaseClassName, out current);
                else
                    current = null;
            }
        }

        return "string"; // default
    }

    private string FormatPrintf(string type, string exprStr, string nl)
    {
        if (type == "string") return $"printf(\"%s{nl}\", {exprStr})";
        if (type == "int" || type == "long") return $"printf(\"%lld{nl}\", (long long){exprStr})";
        if (type == "float" || type == "double") return $"printf(\"%f{nl}\", {exprStr})";
        if (type == "bool") return $"printf(\"%s{nl}\", {exprStr} ? \"true\" : \"false\")";
        if (type == "char") return $"printf(\"%c{nl}\", {exprStr})";
        return $"printf(\"%s{nl}\", {exprStr})";
    }

    /// <summary>
    /// Infers the type of an arbitrary expression for printf formatting.
    /// </summary>
    private string InferExpressionType(Expression expr)
    {
        switch (expr)
        {
            case LiteralExpression lit:
                return lit.LiteralType switch
                {
                    LiteralType.Integer => "int",
                    LiteralType.Float => "float",
                    LiteralType.Boolean => "bool",
                    LiteralType.Char => "char",
                    LiteralType.String => "string",
                    _ => "string"
                };

            case IdentifierExpression id:
                return ResolveExpressionType(id);

            case BinaryExpression bin:
            {
                var op = bin.Operator;
                // Comparison and logical operators always return bool
                if (op == "==" || op == "!=" || op == "<" || op == ">" ||
                    op == "<=" || op == ">=" || op == "&&" || op == "||")
                    return "bool";

                // Arithmetic: infer from operands, promote to widest
                var leftType = InferExpressionType(bin.Left);
                var rightType = InferExpressionType(bin.Right);
                return PromoteNumericType(leftType, rightType);
            }

            case UnaryExpression unary:
            {
                if (unary.Operator == "!")
                    return "bool";
                return InferExpressionType(unary.Operand);
            }

            case PostfixExpression postfix:
                return InferExpressionType(postfix.Operand);

            case MethodCallExpression call:
            {
                var retType = InferMethodCallReturnType(call);
                return retType ?? "string";
            }

            case MemberAccessExpression memberAccess:
            {
                // Try to resolve the member type from the target
                var targetType = InferExpressionType(memberAccess.Target);
                if (_classDeclarations.TryGetValue(targetType, out var classDecl))
                {
                    var field = classDecl.Members.OfType<FieldDeclaration>()
                        .FirstOrDefault(f => f.Name == memberAccess.MemberName);
                    if (field != null) return field.Type.Name;
                }
                // Also check if target is a known variable
                if (memberAccess.Target is IdentifierExpression targetId)
                {
                    var varType = ResolveVariableType(targetId.Name);
                    if (varType != null && _classDeclarations.TryGetValue(varType, out var cls))
                    {
                        var field = cls.Members.OfType<FieldDeclaration>()
                            .FirstOrDefault(f => f.Name == memberAccess.MemberName);
                        if (field != null) return field.Type.Name;
                    }
                }
                return "string";
            }

            case ObjectCreationExpression objCreate:
                return objCreate.TypeName;

            case CastExpression cast:
                return cast.TargetType.Name;

            case ThisExpression:
                return _currentClassName ?? "string";

            case ArrayAccessExpression:
                return "int"; // Default assumption for array elements

            default:
                return "string";
        }
    }

    /// <summary>
    /// Promotes two numeric types to the widest, e.g., int + double => double.
    /// </summary>
    private static string PromoteNumericType(string left, string right)
    {
        if (left == "double" || right == "double") return "double";
        if (left == "float" || right == "float") return "float";
        if (left == "long" || right == "long") return "long";
        if (left == "int" || right == "int") return "int";
        return left; // fallback
    }

    private string? InferMethodCallReturnType(MethodCallExpression call)
    {
        if (call.Target is MemberAccessExpression memberAccess)
        {
            string? className = null;

            if (memberAccess.Target is IdentifierExpression targetId)
            {
                // Handle built-in Math class return types
                if (targetId.Name == "Math")
                    return InferMathReturnType(memberAccess.MemberName);

                // Handle built-in Console class return types
                if (targetId.Name == "Console")
                    return InferConsoleReturnType(memberAccess.MemberName);

                // Direct class access: ClassName.method()
                if (_classDeclarations.ContainsKey(targetId.Name))
                    className = targetId.Name;
                else
                    className = ResolveVariableType(targetId.Name);
            }
            else if (memberAccess.Target is ThisExpression && _currentClassName != null)
            {
                className = _currentClassName;
            }

            if (className != null && _classDeclarations.TryGetValue(className, out var classDecl))
            {
                var chain = GetInheritanceChain(classDecl);
                foreach (var cls in chain)
                {
                    foreach (var member in cls.Members)
                    {
                        if (member is MethodDeclaration m && m.Name == memberAccess.MemberName)
                            return m.ReturnType?.Name ?? "void";
                    }
                }
            }

            // Try extension method return type inference
            if (ExtensionMethods.Contains(memberAccess.MemberName))
            {
                var sourceType = InferExpressionType(memberAccess.Target);
                var extRetType = InferExtensionReturnType(sourceType, memberAccess.MemberName);
                if (extRetType != null)
                    return extRetType;
            }
        }
        return null;
    }

    /// <summary>
    /// Infers the return type of built-in Math methods.
    /// </summary>
    private static string InferMathReturnType(string method)
    {
        return method switch
        {
            "abs" => "int",
            "sqrt" => "double",
            "pow" => "double",
            "min" => "int",
            "max" => "int",
            "floor" => "int",
            "ceil" => "int",
            "round" => "int",
            "sin" or "cos" or "tan" => "double",
            "log" or "log10" => "double",
            _ => "double"
        };
    }

    /// <summary>
    /// Infers the return type of built-in Console methods.
    /// </summary>
    private static string InferConsoleReturnType(string method)
    {
        return method switch
        {
            "readLine" => "string",
            "read" => "int",
            _ => "void"
        };
    }

    // ====================
    // EXTENSION METHODS
    // ====================

    /// <summary>
    /// Known extension methods available on primitive types.
    /// Maps (sourceType, methodName) → runtime function name pattern.
    /// </summary>
    private static readonly HashSet<string> ExtensionMethods =
    [
        "toString", "toInt", "toLong", "toDouble", "toFloat", "toBool", "toChar",
        "round", "roundToInt", "ceil", "floor", "abs", "clamp",
        "length", "isEmpty", "toUpper", "toLower", "trim",
        "substring", "contains", "startsWith", "endsWith",
        "indexOf", "replace", "charAt", "reverse", "padLeft", "padRight"
    ];

    /// <summary>
    /// Tries to generate a call to a built-in extension method on a primitive type.
    /// Returns the C code string if successful, null otherwise.
    /// Extension syntax: expr.method(args) → gg_ext_{type}_{method}(expr, args)
    /// </summary>
    private string? TryGenerateExtensionCall(Expression target, string method, List<Expression> callArgs)
    {
        if (!ExtensionMethods.Contains(method))
            return null;

        var targetType = InferExpressionType(target);
        var cType = MapExtensionType(targetType);

        if (cType == null)
            return null;

        var targetExpr = GenerateExpression(target);
        var extraArgs = callArgs.Select(GenerateExpression).ToList();

        // Build the function call: gg_ext_{cType}_{method}(targetExpr, args...)
        var funcName = $"gg_ext_{cType}_{method}";
        var allArgs = new List<string> { targetExpr };
        allArgs.AddRange(extraArgs);

        return $"{funcName}({string.Join(", ", allArgs)})";
    }

    /// <summary>
    /// Maps a ggLang type name to the C extension type suffix.
    /// Returns null if the type doesn't support extensions.
    /// </summary>
    private static string? MapExtensionType(string typeName)
    {
        return typeName switch
        {
            "int" => "int",
            "long" => "long",
            "double" or "decimal" => "double",
            "float" => "float",
            "bool" => "bool",
            "char" => "char",
            "string" => "string",
            _ => null
        };
    }

    /// <summary>
    /// Infers the return type of extension methods for printf formatting.
    /// </summary>
    private static string? InferExtensionReturnType(string sourceType, string method)
    {
        return method switch
        {
            "toString" => "string",
            "toInt" or "roundToInt" => "int",
            "toLong" => "long",
            "toDouble" => "double",
            "toFloat" => "float",
            "toBool" => "bool",
            "toChar" or "charAt" => "char",
            "round" or "ceil" or "floor" or "abs" => sourceType switch
            {
                "int" => "int",
                "long" => "long",
                "float" => "float",
                _ => "double"
            },
            "clamp" => sourceType,
            "length" or "indexOf" => "int",
            "isEmpty" or "contains" or "startsWith" or "endsWith" => "bool",
            "toUpper" or "toLower" or "trim" or "substring" or "replace"
                or "reverse" or "padLeft" or "padRight" => "string",
            _ => null
        };
    }

    private string GenerateMathCall(string method, List<Expression> args)
    {
        var cArgs = string.Join(", ", args.Select(GenerateExpression));
        return method switch
        {
            "abs" => $"abs({cArgs})",
            "sqrt" => $"sqrt({cArgs})",
            "pow" => $"pow({cArgs})",
            "min" => args.Count == 2
                ? $"(({GenerateExpression(args[0])}) < ({GenerateExpression(args[1])}) ? ({GenerateExpression(args[0])}) : ({GenerateExpression(args[1])}))"
                : $"/* Math.min */",
            "max" => args.Count == 2
                ? $"(({GenerateExpression(args[0])}) > ({GenerateExpression(args[1])}) ? ({GenerateExpression(args[0])}) : ({GenerateExpression(args[1])}))"
                : $"/* Math.max */",
            _ => $"/* Math.{method}({cArgs}) */"
        };
    }

    /// <summary>
    /// Generates calls to Memory.free(obj) and Memory.alloc(size) for
    /// manual memory management (useful in --no-gc mode).
    /// </summary>
    private string GenerateMemoryCall(string method, List<Expression> args)
    {
        var cArgs = string.Join(", ", args.Select(GenerateExpression));
        return method switch
        {
            "free" => $"Memory_free({cArgs})",
            "alloc" => $"Memory_alloc({cArgs})",
            _ => $"/* Memory.{method}({cArgs}) */"
        };
    }

    private string GenerateObjectCreation(ObjectCreationExpression obj)
    {
        var args = string.Join(", ", obj.Arguments.Select(GenerateExpression));
        return $"{obj.TypeName}_create({args})";
    }

    // ====================
    // TYPE MAPPING
    // ====================

    private string MapType(TypeReference? typeRef)
    {
        if (typeRef == null) return "void";

        var baseName = MapTypeName(typeRef.Name);
        if (typeRef.IsArray) return $"{baseName}*";

        if (!IsBuiltinTypeName(typeRef.Name))
        {
            return $"{baseName}*"; // class types are always pointers
        }
        return baseName;
    }

    private string MapTypeName(string? typeName)
    {
        return typeName switch
        {
            "int" => "int",
            "long" => "long long",
            "float" => "float",
            "double" => "double",
            "bool" => "bool",
            "char" => "char",
            "byte" => "unsigned char",
            "short" => "short",
            "string" => "const char*",
            "void" => "void",
            "object" => "void*",
            null => "int",
            _ => typeName
        };
    }

    /// <summary>
    /// Maps a type name to its C representation, adding * for class types.
    /// </summary>
    private string MapTypeNameWithPointer(string? typeName)
    {
        var baseName = MapTypeName(typeName);
        if (typeName != null && !IsBuiltinTypeName(typeName))
            return $"{baseName}*";
        return baseName;
    }

    private static bool IsBuiltinTypeName(string name)
    {
        return name is "int" or "long" or "float" or "double" or "bool"
                    or "char" or "byte" or "short" or "string" or "void" or "object";
    }

    // ====================
    // UTILITIES
    // ====================

    private void Emit(string line)
    {
        var indent = new string(' ', _indentLevel * 4);
        _implementations.AppendLine($"{indent}{line}");
    }

    private static string EscapeString(string s)
    {
        return s.Replace("\\", "\\\\")
                .Replace("\"", "\\\"")
                .Replace("\n", "\\n")
                .Replace("\r", "\\r")
                .Replace("\t", "\\t");
    }
}
